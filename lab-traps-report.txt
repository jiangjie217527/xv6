# traps

## backtrace

Easy job. My technique is that backtrace() is just a kernel function, which is similar with something like kalloc(). So it is easy to config the call and finish everything in this function body. All I need to do is to go through the stack, which begins with using r_fp(). Then write a loop, print the address and get to the next frame to finish this task.

## alarm

### task0

This is much more interesting than the above job and involves more techniques.

To finish this task, I add 3 field in proc, two int and one uint64,which is the address of the handler. In my opinion, once the address is passed as the argunment with type (*handler)() , I will catch it and stored it as uint64, which make the program easier to read.

Then, in usertrap(), I find the trap handler which is generated by a timer. Once the required interval has been satisfied, I change the epc(user program counter) and reset the ticks.

One mistake I made is that I think the user's alarm function shouldn't be zero (How dare you think that one valid address is zero?) So I add a line saying that if the address is zero, don't change the epc, which makes the task fail. When testing, I noticed that the test takes a long time but did't alarm, whats more, I output something to find that the ticks got reset many times but just won't activate the alarm, then I know my mistake.

### task1

This task is a little easy but a little more tricky. This task need to do 3 things, one is resuming the interrupted code, second is preventing getting alarm during doing the alarm handler, last is "restore a0".

In the first task, I choose to copy the whole trapframe in alarmframe. This requires me to add a new filed in proc and I must alloc some memory to this field when initializing the proc at allocporc(). I copied the alloc method just lick trapframe. Also, alloc need free. So I also free this memory space at freeproc(). In this way, it is easy to resume the interrupted code, with everything backed up, including epc and other context.

The second task is easy to add a field called in_trap in proc to mark whether this program is in a trap. If so, just block the change of epc in trapframe.

Finally, I met the last simple task but got confused. I looked into user/alarmtest.c and found that no lines catch the return value of sigreturn()! (I thought this function as a common function and think that the return value should be caught like "int a = f()"). So I tried to really store the return value in a0. But a0 has already in p->trapframe->a0! Where else can I store this register! Later I understand the true meaning of "sigreturn is a system call, return value is stored in a0". This means that I just need to modify the "return 0" into something like "return ret" and ret is the required return value in p->trapframe->a0. After return, the alarmtest will get this. Just such a small and easy modification!

## That's all. Graded and finished.
